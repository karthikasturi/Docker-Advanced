# Creating a Custom Seccomp Profile for Docker

## Step 1: Get Dockerâ€™s Default Seccomp Profile

Docker ships with a default profile. You can fetch it with:

```bash
curl -O https://raw.githubusercontent.com/moby/moby/master/profiles/seccomp/default.json
```

This file defines:

- Allowed syscalls
- Blocked syscalls
- Argument filters
- Default action (e.g. `SCMP_ACT_ERRNO`)

---

## Step 2: Create the custom seccomp profile

Create a file named `block_getcwd.json` (you can create it anywhere on your Ubuntu host, e.g., in your home directory or a dedicated `seccomp-profiles` folder):

```json
{
  "defaultAction": "SCMP_ACT_ALLOW",
  "architectures": [
    "SCMP_ARCH_X86_64",
    "SCMP_ARCH_AARCH64",
    "SCMP_ARCH_ARM"
  ],
  "syscalls": [
    {
      "names": [
        "getcwd"
      ],
      "action": "SCMP_ACT_ERRNO"
    },
    {
      "names": [
        "exit",
        "exit_group"
      ],
      "action": "SCMP_ACT_ALLOW"
    }
  ]
}
```

Or to allow something new, change its `"action"` to `"SCMP_ACT_ALLOW"`.

---

## Step 3: Create a Test Application (Inside the Container)

We need a simple application that attempts to use `getcwd` so we can observe the effect of our Seccomp profile. We'll use a simple C program.

1. **Create `test_getcwd.c` on your Ubuntu host:**

```c
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h> // For strerror

int main() {
    char cwd[1024];
    if (getcwd(cwd, sizeof(cwd)) != NULL) {
        printf("Current working directory: %s\n", cwd);
    } else {
        perror("getcwd failed");
        printf("Error number: %d\n", errno);
        printf("Error message: %s\n", strerror(errno));
    }
    return 0;
}
```

2. Create a `Dockerfile` to build this application:
   
   ```dockerfile
   # Use a base image with a C compiler
   FROM gcc:latest
   
   # Copy the source code into the container
   COPY test_getcwd.c /app/
   
   # Compile the C program
   WORKDIR /app
   RUN gcc test_getcwd.c -o test_getcwd
   
   # Set the entrypoint to run the compiled program
   CMD ["./test_getcwd"]
   ```

## Step 3: Build the Docker Image

Navigate to the directory containing `block_getcwd.json`, `test_getcwd.c`, and `Dockerfile`.

```bash
docker build -t getcwd-test-app .
```

## **Step 4: Test the Seccomp Profile**

Now, let's run the container, first *without* the profile to see normal behavior, and then *with* the profile.

**Test 4a: Without Seccomp Profile (Expected: Success)**

```bash
docker run --rm getcwd-test-app
```

**Expected Output:**

```bash
Current working directory: /app
```

You're on the right track! Custom Seccomp profiles are a powerful way to harden your Docker containers by restricting the system calls they can make. Since you're using Docker Desktop, the process of applying and testing is the same, as the Seccomp profile is applied *inside* the Docker Desktop VM's kernel where your containers run.

Here's how to create a custom Seccomp profile to block `getcwd` and test it:

**Understanding Seccomp Profiles**

- **JSON Format:** Docker's Seccomp profiles are written in JSON.

- **`defaultAction`:** This defines what happens to syscalls not explicitly listed. Common actions:
  
  - `SCMP_ACT_ALLOW`: Allow all unlisted syscalls (blacklist approach).
  
  - `SCMP_ACT_ERRNO`: Deny all unlisted syscalls with an EPERM error (whitelist approach - generally more secure).
  
  - `SCMP_ACT_KILL`: Terminate the process if an unlisted syscall is attempted.
  
  - `SCMP_ACT_LOG`: Log the syscall attempt (useful for debugging, but still allows the syscall).

- **`syscalls` array:** This is where you list specific syscalls and their actions.
  
  - `name`: The name of the syscall (e.g., "getcwd").
  
  - `action`: The action to take for this specific syscall, overriding `defaultAction`.

**Step 1: Create the Custom Seccomp Profile (JSON File)**

We'll start with a minimal profile that allows most things but explicitly blocks `getcwd`. It's generally safer to *whitelist* syscalls, but for demonstrating blocking a specific one, we'll use `SCMP_ACT_ALLOW` as the default and then `SCMP_ACT_ERRNO` for `getcwd`.

Create a file named `block_getcwd.json` (you can create it anywhere on your Ubuntu host, e.g., in your home directory or a dedicated `seccomp-profiles` folder):

JSON

```
{
  "defaultAction": "SCMP_ACT_ALLOW",
  "architectures": [
    "SCMP_ARCH_X86_64",
    "SCMP_ARCH_AARCH64",
    "SCMP_ARCH_ARM"
  ],
  "syscalls": [
    {
      "names": [
        "getcwd"
      ],
      "action": "SCMP_ACT_ERRNO"
    },
    {
      "names": [
        "exit",
        "exit_group"
      ],
      "action": "SCMP_ACT_ALLOW"
    }
  ]
}
```

**Explanation of this profile:**

- `"defaultAction": "SCMP_ACT_ALLOW"`: By default, allow all system calls.

- `"architectures"`: It's good practice to specify the architectures your profile is valid for. `X86_64` is for most desktop/server systems. `AARCH64` and `ARM` are common for other platforms (e.g., Raspberry Pi, M1/M2 Macs running Docker Desktop).

- `"syscalls"`:
  
  - The first entry `{"names": ["getcwd"], "action": "SCMP_ACT_ERRNO"}` explicitly blocks the `getcwd` syscall, making it return a "Permission Denied" error (`EPERM`).
  
  - The second entry `{"names": ["exit", "exit_group"], "action": "SCMP_ACT_ALLOW"}` is crucial. If you use `SCMP_ACT_ERRNO` or `SCMP_ACT_KILL` as `defaultAction`, you *must* explicitly allow `exit` and `exit_group` (and usually `read`, `write`, `brk`, `fstat`, etc.) otherwise your container won't even start or will crash immediately. In our case, since `defaultAction` is `ALLOW`, this specific `ALLOW` for `exit` is redundant but harmless; it's good practice to keep in mind for more restrictive profiles.

**Step 2: Create a Test Application (Inside the Container)**

We need a simple application that attempts to use `getcwd` so we can observe the effect of our Seccomp profile. We'll use a simple C program.

1. **Create `test_getcwd.c` on your Ubuntu host:**
   
   C
   
   ```
   #include <stdio.h>
   #include <unistd.h>
   #include <errno.h>
   #include <string.h> // For strerror
   
   int main() {
      char cwd[1024];
      if (getcwd(cwd, sizeof(cwd)) != NULL) {
          printf("Current working directory: %s\n", cwd);
      } else {
          perror("getcwd failed");
          printf("Error number: %d\n", errno);
          printf("Error message: %s\n", strerror(errno));
      }
      return 0;
   }
   ```

2. **Create a `Dockerfile` to build this application:**
   
   Dockerfile
   
   ```
   # Use a base image with a C compiler
   FROM gcc:latest
   
   # Copy the source code into the container
   COPY test_getcwd.c /app/
   
   # Compile the C program
   WORKDIR /app
   RUN gcc test_getcwd.c -o test_getcwd
   
   # Set the entrypoint to run the compiled program
   CMD ["./test_getcwd"]
   ```

**Step 3: Build the Docker Image**

Navigate to the directory containing `block_getcwd.json`, `test_getcwd.c`, and `Dockerfile`.

Bash

```
docker build -t getcwd-test-app .
```

**Step 4: Test the Seccomp Profile**

Now, let's run the container, first *without* the profile to see normal behavior, and then *with* the profile.

**Test 4a: Without Seccomp Profile (Expected: Success)**

Bash

```
docker run --rm getcwd-test-app
```

**Expected Output:**

```
Current working directory: /app
```

(Or similar, depending on the container's initial working directory). This confirms the application works normally.

**Test 4b: With Custom Seccomp Profile (Expected: Failure)**

Now, run the container and apply your custom Seccomp profile using the `--security-opt seccomp=<path_to_profile.json>` flag.

**Important:** Provide the **absolute path** to your `block_getcwd.json` file.

```bash
# Replace /path/to/your/block_getcwd.json with the actual path
docker run --rm --security-opt seccomp=/path/to/your/block_getcwd.json getcwd-test-app
```

**Expected Output:**

```bash
docker: Error response from daemon: failed to create task for container: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: error during container init: failed to verify if current working directory is safe: operation not permitted: unknown

Run 'docker run --help' for more information
```
