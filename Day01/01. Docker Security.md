## Demo: Scan Public Image with Trivy

```bash
docker pull node:18
trivy image node:18
```

**Expected Output:**

- Total: 100+ vulnerabilities
- High/Critical vulnerabilities from base image (Debian/Ubuntu) and Node.js packages

## Step 1: Build a Secure Docker Image

Create a `Dockerfile`:

```Dockerfile
FROM alpine:latest
RUN apk update && apk add strace
RUN adduser -D appuser
USER appuser
CMD ["sh"]  
```

Build the image:

```bash
docker build -t secure-alpine .
```

Run to verify:

```bash
docker run secure-alpine id
```

## Step 2: Run with Least Privilege

```bash
docker run \
  -it \  
  --rm \
  --user 1000 \
  --read-only \
  --cap-drop=ALL \
  --security-opt no-new-privileges:true \
  --tmpfs /tmp \
  secure-alpine
```

 Test file writes inside container:

```bash
touch /tmp/test     # should succeed
touch /etc/test     # should fail
```

## Step 3: Add seccomp and AppArmor

Run with Docker defaults: (seccomp defualt profile will be applied by default)

```bash
docker run \
  -it \
  --security-opt apparmor=docker-default \
  -v /sys/kernel/debug:/sys/kernel/debug \  
  secure-alpine
```

```bash
mkdir /mnt/test
mount -t tmpfs tmpfs /mnt/test
```

**Expected output**:
mount -t tmpfs tmpfs /mnt/test
mount: permission denied (are you root?)

**Try writing to /sys/kernel/debug**: 

```bash
echo "test" > /sys/kernel/debug/test
```

**Expected output**:
sh: can't create /sys/kernel/debug/test: Permission denied

## Step 4: Trivy Scan on Custom Image

```bash
trivy image secure-alpine
```

Compare with a vulnerable image:

```bash
docker pull ubuntu:18.04
trivy image ubuntu:18.04
```

## Optional: Sign Image with Cosign

Assuming you have an account and repository in docker hub or any other registry, and had a image pushed. we can create a key pair, sign and also verify that published image.

```bash
cosign generate-key-pair
cosign sign --key cosign.key <username>/secure-alpine
cosign verify --key cosign.pub <username>/secure-alpine
```

## Extra Challenges

- Use `distroless` or `scratch` as base image

## Practical Example: Go App with Scratch

```Dockerfile
# Build stage  
FROM golang:1.21 as builder  
WORKDIR /app  
COPY main.go .  
RUN CGO_ENABLED=0 go build -o myapp  

# Final stage  
FROM scratch 
COPY --from=builder /app/myapp /myapp  
ENTRYPOINT ["/myapp"]  
```

 Result: ~2MB image with **zero shell access, zero CVEs**

---

## Practical Example: Python App with Distroless

Dockerfile

```dockerfile
FROM python:3.11-slim as builder
WORKDIR /app
COPY . .
RUN pip install --target /app/deps -r requirements.txt

FROM gcr.io/distroless/python3
COPY --from=builder /app /app
WORKDIR /app
ENTRYPOINT ["python3", "main.py"]
```

Result: Minimal Python image without pip, apt, or shell

- Integrate image scanning in GitHub Actions CI pipeline
